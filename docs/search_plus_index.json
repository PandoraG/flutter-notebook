{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction 以下是一些学习资料： Dart2 中文文档 | 看云 Dart2 中文文档 | 极客 Flutter 中文文档 Flutter 实战 Flutter 从入门到精通 "},"jichu/dart-getting.html":{"url":"jichu/dart-getting.html","title":"dart 基础入门","keywords":"","body":"1、Dart 基础知识 1.1 程序入口 Js 没有预定义的入口函数，但在 Dart 中，每个 app 都必须有一个顶级的 main() 函数作为应用程序的入口点。 // Dart main() { } DartPad是 Dart 的一个线上 playground, 提供 Dart 线上 playground 还有：Online dart compiler 1.2 控制台输出 要在 Dart 中打印到控制台，可使用 print: // js console.log('hello world'); // dart print('hello world'); 1.3 变量 Dart 是类型安全的 - 它使用静态类型检查和运行时的组合，检查以确保变量的值始终与变量的静态值匹配 类型。尽管类型是必须的，但某些类型注释是可选的，因为 Dart 会执行类型推断。 1.3.1 创建变量 在 js 中，无法定义变量类型。 在 dart 中，变量必须是明确的 类型和系统能够解析的类型。 // js var name = 'js' // dart String name = 'dart'; //明确指定是String类型 var othername = 'Dart'; //推断为string // 以上两种情况在dart中都是可行的 1.3.2 默认值 在 js 中，未初始化的变量是 undefined。 在 dart 中，未初始化的变量的初始值是 null。 注意：数字在 Dart 中也被当成对象，所以只要是带有数字类型的未初始化变量的值都是 “null”。 // js var name; // == undefined // Dart var name; // == null int x; // == null 1.4 检查 null 或零 在 Js 中， 1或任何非 null 对象的值被视为 true。 // Js var myNull = null; if (!myNull) { console.log('null is treated as false'); } var zero = 0; if (!zero) { console.log(\"0 is treated as false); } 在 Dart 中，只有布尔值 “true”被视为 true。 // Dart var myNull = null; if (myNull == null) { print('user \"== null\" to check null'); } var zero = 0; if (zero == 0) { print('user \"== 0\" to check zero'); } 1.4.1 Dart null 检查最佳实践 从 Dart 1.12 开始，null-aware运算符 可用帮助我们做null检查： bool isConnected(a, b) { bool outConn = outgoing[a]?.contains(b) ?? false; bool inConn = incoing[a].contains(b) ?? false; return outConn || isConn; } ?.运算符在左边为 null 情况下会阻断右边的调用，??运算符主要作用是在左侧表达式为 null 时为其设置默认值。 对于表达式： outgoing[a]?.contains(b); 如果 outgoing 为 null 或 outgoing[a]为 null 或 contains(b)的值为 null，都会导致表达式为 null。 print(null ?? false) //false print(false ?? 11); //11 print(true ?? false); //true 技巧： 获取一个对象中数组的长度： searchModel?.data?.length ?? 0。 1.5 Functions Dart 和 JavaScript 函数类似，主要区别是声明： // js es5 function fn() { return true; } // Dart fn() { return false; } // 也可以写成这样 bool fn() { return false; } 1.6 异步编程 1.6.1 Futures 与 Js 一样，Dart 支持单线程执行。在 JavaScript 中，Promise对象表示异步操作的最终完成（或失败）及其结果值，Dart 中使用 Future 来表示异步操作： // js _getIpAddress = () => { const url = 'https://httpbin.org/ip'; return fetch(url) .then(response => response.json()); .then(responseJson => { console.log(responseJson.origin()); }) .catch(error => { console.error(error); }) } // Dart _getIpAddress() { final url = 'https://httpbin.org/ip'; HttpRequest.request(url).then((value) { print(json.decode(value.responseText)['origin']); }).catchError((error) => print(error)); } 实例： import 'dart:convert'; import 'dart:html'; void main() { _getIpAddress() { final url = 'https://httpbin.org/ip'; Future request = HttpRequest.request(url); request.then((value) { print(json.decode(value.responseText)['origin']); }).catchError((error) => print(error)); } _getIpAddress(); } 1.6.2 async 和 await async 函数声明定义一个异步函数。 在 JavaScript 中，async函数返回一个 Promise 对象。await运算符是用在等待Promise； // javascript async _getIpAddress() { const url = 'https://httpbin.org/ip'; const response = await fetch(url); const json = await response.json(); const data = await json.origin(); console.log(data); } 在 Dart 中，async函数返回一个Future, 函数的主题是稍后执行的。await运算符用于等待 Future。 _getIpAddress() async { final url = 'https://httpbin.org/ip'; var request = await HttpRequest.request(url); //通过await标识请求，返回的是一个Future String ip = json.decode(request.responseText['origin']) //通过resposneText获取具体ip print(ip) } "},"jichu/what-is-declarative-ui.html":{"url":"jichu/what-is-declarative-ui.html","title":"什么是声明式 UI","keywords":"","body":"1、什么是声明式 UI Flutter 采用了声明性 UI 布局方式，为了帮助大家快速上手，我们要先学习什么是声明式 UI, 以及它和我们常用的命令式 UI 的异同。 1.1 为什么是声明式 UI？ 从 Win32 到 Web 在到 Android 和 iOS 的框架通常使用命令式的 UI 编程风格。这可能是我们最熟悉的样式 - 你手动构建全功能 UI 实体（如 UIView 或等效实体），然后在 UI 更改时使用方法对其进行更改。 为了减轻开发人员在各种 UI 状态之间转换的编程负担，Flutter 让开发人员描述当前的 UI 状态，并不需要关心她是如何过渡到框架。 虽然声明式 UI 能帮我们减轻很多负担，但大家要将布局的思维方式要转变过来。 1.2 如何在声明框架中更改 UI? 下面是个简单的例子： 为了将上图左侧样式改成右边的样子，在命令样式中，我们通常会获取的 ViewB 的实例，然后改变其颜色，然后将启动的元素删除，在添加 ViewC c3: // Imperative style b.setColor(red) b.clearChildren() ViewC c3 = new ViewC(...) b.add(c3) 在声明式 UI 中，视图配置（例如 Flutter 的 widget）是不变的，并且只是轻量级“蓝图”。要更改 UI，Widget 会在自身上触发重建（最常见的是通过在 Flutter 中的 StatefulWidgets 上调用 setState()) 并构建一个新的 Widgets 子树： // Declarative style return ViewB( color: red, child: ViewC(....), ) 这里，Flutter 构建新的 Widget 实例，而不是在 UI 更改时改变旧实例 b。 该框架使用 RenderObjects 管理传统 UI 对象的许多职责（例如维护布局的状态）。RenderObjects 在帧之间保持不变，Flutter 的轻量级 Widgets 告诉框架在状态 RenderObjects，接下来 Flutter 框架会处理其与部分。 "},"jichu/flutter-getting.html":{"url":"jichu/flutter-getting.html","title":"Flutter 入门基础","keywords":"","body":"1 如何创建 Flutter 项目？ 要创建一个 Flutter 项目有一下两种方式： 从命令行使用 flutter create 命令。确保 flutter SDK 配置了环境变量。 使用安装了 Flutter 和 Dart 插件的 IDE。 $ flutter create 2 如何运行 Flutter 项目？ 在 Flutter 中，我们通过以下两种方式来运行项目： 从项目的根目录使用 flutter run。 在带有 Flutter 和 Dart 插件的 IDE 中使用 “run” 选项。 $ flutter run -d 'iphone X' d 后面跟的是具体的设备名称，可以是 Android 或 iOS 模拟器的名字，也可以一台已经连接到电脑上的 Android 或 iOS 的设备。 3 如何导入 Widget? 在 Flutter 中，要使用 Material Design 库中的小部件，则需要导入 material.dart 包。要使用 iOS 样式 widget, 请导入Cupertino 库。要使用更基本的窗口 widget 集，请导 widget 库。或者，当然，也可以导入自己编写的 widget: import 'package:flutter/material.dart'; //导入系统material widget库 import 'package:flutter/cupertino.dart'; import 'package:flutter/widgets.dart'; import 'package:flutter/my_widgets.dart'; //导入自己的widget 无论您导入哪个 widget 包，Dart 都只会导入在您的应用中使用的 widget。 4 如何写一个 Hello world? 在 Flutter 中，您可以创建一个完全相同的“Hello world!” 应用程序使用核心窗口小部件库中 Center 和 Text 窗口小部件。Center 窗口小部件成为窗口小部件树的根，并且有一个子窗口，即“Text”窗口小部件。 // Flutter import 'package:flutter/material.dart'; void main() { runApp( Center( child: Text( 'Hello world!', textDirection: TextDirection.ltr, ), ), ); } 得益于 Flutter 强大的封装能力，我们不难发现实现相同的功能，Flutter 要比 RN 少很多代码。 5 如何使用 Widget 并将其嵌套以形成 Widget 树？ 在 Flutter 中，几乎所有东西都是 widget。 widget 是用户界面的基本构建块，您将 widget 组成一个层次结构，调用 widget 树。每个窗口 widget 都嵌套在父窗口 widget 中，并从其父窗口继承属性。甚至应用程序对象本身也是一个组件，并没有单独的“应用程序”对象。相反，根 widget 担任此角色。 Widget 可以定义： 结构元素 - 如按钮或菜单 文本元素 - 像字体或颜色主题 类似布局的填充或对齐的一个方向 以下示例使用 Material 库中的 Widget 显示“Hello world!” 应用程序。在此示例中，widget 树嵌套在 MaterialApp 的根 widget 中。 // Flutter import 'package:flutter/material.dart'; void main() => runApp(myApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: Text('Welcome to Flutter'), ), body: Center( child: Text('Hello world'), ), ), ); } } 以上图片显示了使用 Material Design 小部件构建的“Hello world!\"。 6 如何创建可重用 Widget? 在 Flutter 中，同样需要定义一个类来创建自定义 widget，然后重用 widget。您还可以定义和调用返回可重用小部件的函数，如以下示例中的构建函数所示： //Flutter class CustomCard extents StatelessWidget { CustomCard({@required this.index, @required this.onPress}); final index; final Function onPress; @override Widget build(BuildContext context) { return Card( child: Column( children: [ Text('Card $index'), FlatButton( child: const Text('Press'), onPressed: this.onPress, ), ], ) ); } } ... // Usage CustomCard( index: index, onPress: () { print('Card $index'); }, ) ... 在前面的例子中，CustomCard 类的构造函数使用 Dart 的大括号语法{}来配置可选参数。 如果要表示必须的字段，请从构造函数中删除花括号，或者将@required 添加到构造函数中。 "},"jichu/project-structure-resources.html":{"url":"jichu/project-structure-resources.html","title":"项目结构、资源、依赖和本地化","keywords":"","body":"1 项目的结构时怎样子的？ projextnam android - Android部分的工程文件 build - 项目的构建输出目录 ios - ios部分的工程文件 lib - 项目中的Dart源文件 src - 包含其他源码的文件 main.dart - 自动生成的项目入口文件，类似于RN的index.js文件 test - 测试相关文件 pubspec.yaml - 项目依赖配置文件类似于RN的package.json 2 在哪里归档图片资源以及如何处理不同分辨率？ 虽然 Android 将 resources 和 assets 区别对待，但在 Flutter 中它们都会被作为 assets 处理，所 有存在于 Android 上 res / drawable- * 文件夹中的资源都放在 Flutter 的 assets 文件夹中。 与 Android 类似，iOS 同样将 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。 被放到 iOS 中 Images.xcasset 文件央下的资源在 Rutter 中被放到了 assets 文件央中。 在 Flutter 中 assets 可以是任意类型的文件，而不仅仅是图片。 例如，你可以把 json 文件放置到 my-assets 文件夹中。 my-assets/data.json 记得在 pubspec.yaml 文件中声明 assets : assets: - my-assets/data.json 然后在代码中我们可以通过 AssetBundle 来访问它: import 'dart:async' show Future; import 'package:f1utter/services.dart' show rootBundle; Future loadAsset() async { return await rpotBundle.loadString('my-assets/data.json'); } 对于图片，Flutter 像 iOS—样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 1.Ox 2.0x 3.0x 或是其他的任何倍数。这个 devicePixelRatio 表示了物理像素到单个逻辑像素的比率。 Android 不同像素密度的图片和 Flutter 的像素比率的对应关系 ldpi 0.75px mdpi 1.0px hdpi 1.5px xhdpi 2.0px xxhdpi 3.0px xxxhdpi 4.0px Assets 可以被放置到任何属性文件夹中一一 Rutter 并没有预先定义的文件结构。我们需要在 pubspec.yaml 文件中声明 assets 的位置，然后 Flutter 会把他们识别出来。 举个例子，要把_个名为 my_icon.png 的图片放到 Flutter 工程中，你可能想要把它放到 images 文件夹中。把图片（1.0x)放置到 images 文件央中，并把其它分辨率的图片放在对应的子文件央中，并接上合适的比例系数，就像这样： images/my_icon.png // Base: 1.0x image images/2.0x/my一icon■png // 2.0x image images/3.0x/my一icon.png //3.0x image 接下来就可以在 pubspec.yaml 文件中这样声明这个图片资源: asserts: - images/my_icon.png 现在，我们就可以借助 Assetlmage 来访问它了。 return AssetImage('images/a_dot_burr.jpeg'); 也可以通过 Image widget 直接使用： @override Widget build(BuildContext context) { return Image.asset(\"images/my_image.png\"); } 3 如何归档 strings 资源，以及如何处理不同语言？ 不像 iOS 拥有一个 Localizaple. strings 文件，Flutter 目前没有专门的字符串资源系统。目 前，最佳做法是将 strings 资源作为静态字段保存在类中。例如： class Strings { static String welcomeMessage = \"Welcome To Flutter\"; } 然后像如下方式来访问它: Text(Strings.welcomeMessage) 默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 flutter_Localizations包。你可能也要引入 inti 包来支持其他的 i10n 机制，比如日期/时间格式化。 dependencies: # ... flutte「一localizations: sdk: flutter intl: \"^0.15.6\" 要使用 flutter_localizations 包 ， 还需要在 appwidget 中指定 localizationsDelegates 和 supportedLocales。 import 'packagerflutter_localizations/flutter_localizations.dart'; MaterialApp( localizationsDelegates: [ // Add app-specific localization delegate[s] here GlobaIMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale(,en'# 'US'), // English const Locale('he', 'IL'), // Hebrew // ... other locales the app supports ], // ... } 这些代理包括了实际的本地化值，并且 supportedLocales 定义了 App 支持哪些地区。上面的例子使用了一个 MaterialApp, 所以它既有 GlobaIWidgetsLocalizations 用于基础 widgets, 也有 MateriaIWidgetsLocalizations 用于 Material wigets 的本地化。如果你使用 WidgetsApp，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本她化副本。 当初始化时，WidgetsApp 或 MaterialApp 会使用你指定的代理为你创建一个 Localizations widget。Localizations widget 可以随时从当前上下文中访问设备的地点，或者使用 Window.locale。 要访问本地化文件，使用 Localizations.of()方法来访问提供代理的特定本地化类。如需翻译，使用 intl_translation 包来取出翻译副本到 arb 文件中。把它们引入 App 中，并用 inti 来使用它们。 更多 Flutter 中国际化和本地化的细节，请访问 internationalization guide , 里面有不使用 inti 包的 示例代码。 注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能再原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。 4 如何添加 Flutter 项目所需的依赖？ 在 Android 中，你可以在 Gradle 文件来添加依赖项目； 在 iOS 中，通常把依赖添加到 Podfile 中； 在 RN 中，通常是由 package.json 来管理项目依赖； Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将 Android 和 iOS native 包装应用程序的构建委派给响应的构建系统。 dependencies: flutter: sdk: flutter google_sign_in: ^3.0.3 在 Flutter 中，虽然在 Flutter 项目中的 Android 文件夹下有 Gradle 文件，但只有在添加平台相关需求的依赖关系时才会使用到这些文件。否则，应该使用 pubspec.yaml 来声明用于 Flutter 的外部依赖项。 iOS 也一样，如果你的 Flutter 工程中的 iOS 文件夹中有 Podfile， 请仅在添加 iOS 平台相关依赖时使用它。否则，应该使用 pubspec.yaml 来声明用于 Flutter 的外部依赖项。 推荐一个用于查找 Flutter 插件的网站： Pub site。 "},"jichu/know-view.html":{"url":"jichu/know-view.html","title":"认识视图（Views）","keywords":"","body":"https://www.devio.org/2019/03/16/flutter-views/ "},"jichu/state-manage.html":{"url":"jichu/state-manage.html","title":"状态管理","keywords":"","body":"https://www.devio.org/2019/03/23/flutter-statelesswidget-statefulwidget/ "},"jichu/route-and-navigation.html":{"url":"jichu/route-and-navigation.html","title":"路由与导航","keywords":"","body":"https://www.devio.org/2019/03/31/flutter-router-navigator/ "},"jichu/dart_sdk/dart_ui.html":{"url":"jichu/dart_sdk/dart_ui.html","title":"库 dart:ui","keywords":"","body":" 阅读原文 dart:ui 库 Flutter 应用程序的内置类型和核心原语。 使用： import 'dart:ui' 该库提供 Flutter 框架 用于引导应用程序（bootstrap applications）的最低级别的服务，例如：用于驱动输入，图形文本，布局和渲染子系统的类。 1. 类 2. 属性 2.1 channelBuffers → ChannelBuffers 允许在引擎和框架之间存储消息的 ChannelBuffers。通常，无法传递的消息会存储在此处，直到框架能够处理它们为止。 [...] final 2.2 window → Window Window 单例. [...] final 3. 方法 4. 枚举 5. 类型定义 "},"jichu/dart_sdk/dart_core.html":{"url":"jichu/dart_sdk/dart_core.html","title":"库 dart:core","keywords":"","body":" 原文 dart:core 库 每个 Dart 程序的内置类型（types），集合(collections)和其他核心功能(core functionality)。 该库是自动导入的。 该库中的某些类（例如 String 和 num）支持 Dart 的内置数据类型。其他类，例如 List 和 Map，提供了用于管理对象集合的数据结构。还有其他类表示常用的数据类型，例如 URI，日期和时间以及错误。 数字和布尔值 int 和 double 提供对 Dart 内置数字数据类型的支持：分别为整数和双精度浮点数。 bool 类型的对象为 true 或 false。这些类型的变量可以从文字(literals)构造： int meaningOfLife = 42; double valueOfPi = 3.141592; bool visible = true; 字符串和正则表达式 字符串是不可变的，代表一系列字符。 String shakespeareQuote = \"All the world's a stage, ...\"; StringBuffer 提供了一种有效构造字符串的方法。 StringBuffer moreShakespeare = new StringBuffer(); moreShakespeare.write('And all the men and women '); moreShakespeare.write('merely players; ...'); String 和 StringBuffer 类实现字符串连接，插值和其他字符串操作功能。 String philosophy = 'Live on '; String get palindrome => philosophy + philosophy.split('').reversed.join(); RegExp 实现 Dart 正则表达式，该正则表达式提供了用于匹配文本内的模式的语法。例如，这是一个匹配一个或多个数字的字符串的正则表达式： var numbers = new RegExp(r'\\d+'); Dart 正则表达式与 JavaScript 正则表达式具有相同的语法和语义。有关 JavaScript 正则表达式的规范，请参见 ecma-international.org/ecma-262/5.1/#sec-15.10。 集合（Collections） dart:core 库提供了基本集合，例如 List，Map 和 Set。 列表(List)是对象的有序集合，具有一定长度。List 有时称为数组。当需要按索引访问对象时，请使用 List。 List superheroes = [ 'Batman', 'Superman', 'Harry Potter' ]; Set 是一个无重复项且无序对象集合。您无法按 index（position）获得 item。如果你添加了重复的项则会无效。 Set villains = new Set(); villains.add('Joker'); villains.addAll( ['Lex Luther', 'Voldemort'] ); Map 是无序的键值对集合。Map 有时称为关联数组，因为映射(maps)将键关联到某个值(value)以便于检索。键(Keys)是唯一的。需要通过唯一标识符访问对象时请使用 Map。 Map sidekicks = { 'Batman': 'Robin', 'Superman': 'Lois Lane', 'Harry Potter': 'Ron and Hermione' }; 除了这些类之外，dart:core 包含 Iterable，这是一个接口，用于定义对象集合中常见的功能。例如：在集合中的每个元素上运行功能，对每个元素进行测试，检索对象以及确定长度的能力。 Iterable 由 List 和 Set 实现，并通过 Map 关联键和值。 对于其他种类的集合，请查看 art:collection 库。 日期与时间（Date and time） 使用 DateTime 表示一个时间点，并使用 Duration 表示时间跨度。 您可以使用构造函数或通过解析正确格式的字符串来创建 DateTime 对象。 DateTime now = new DateTime.now(); DateTime berlinWallFell = new DateTime(1989, 11, 9); DateTime moonLanding = DateTime.parse(\"1969-07-20\"); 创建一个 Duration 对象，指定各个时间单位。 Duration timeRemaining = new Duration(hours:56, minutes:14); 除了 DateTime 和 Duration 之外，dart:core 包含用于测量经过时间的 Stopwatch类。 Uri A Uri object represents a uniform resource identifier, which identifies a resource on the web. Uri dartlang = Uri.parse('http://dartlang.org/'); 错误（Errors） Error 类表示运行时发生错误。此类的子类表示特定类型的错误。 其他文件（Other documentation） 有关如何使用内置类型的更多信息，请参阅Dart：启动和运行第二章中的内置类型。 另外，请参阅 dart:core - Numbers, Collections, Strings, and More 有关此包中类的更多信息。 另外，有关此包中类的更多信息，请参见 dart：core-数字，集合，字符串和更多内容。 Dart 语言规范提供了技术细节。 Classes "},"jichu/dart_sdk/dart_async.html":{"url":"jichu/dart_sdk/dart_async.html","title":"库 dart:async","keywords":"","body":" 阅读原文 dart:async 库 支持诸如 Future 和 Stream 之类的异步编程。 了解 Futures 和 Streams 是编写任何 Dart 程序的先决条件。 要在您的代码中使用此库： import 'dart:async'; Future Future 对象表示其返回值可能尚不可用的计算。当将来某个时候完成时，Future 返回计算的值。Futures 通常用于潜在的冗长计算，例如 I/O 和与用户的交互。 执行任务时，Dart 库中的许多方法都会返回 Future。例如，将 HttpServer 绑定到主机和端口时，bind()方法将返回 Future。 HttpServer.bind('127.0.0.1', 4444) .then((server) => print('${server.isBroadcast}')) .catchError(print); Future.then 注册一个回调函数，该函数在 Future 的操作（在本例中为 bind()方法）成功完成时运行。该操作返回的值将传递到回调函数中。在此示例中，bind() 方法返回 HttpServer 对象。回调函数将打印其属性之一。 Future.catchError 注册一个回调函数，如果在 Future 中发生错误，该函数将运行。 Stream Stream 提供异步的数据序列。数据序列的示例包括单个事件（例如鼠标单击）或较大数据的连续块（​​ 例如带有文件内容的多个字节列表，例如鼠标单击）以及从文件读取的字节列表流。以下示例打开一个文件以供读取。 Stream.listen 注册一个回调函数，该函数在每次有更多数据可用时运行。 Stream> stream = new File('quotes.txt').openRead(); stream.transform(utf8.decoder).listen(print); 该流发出一系列字节列表。程序必须解释字节或处理原始字节数据。在这里，代码使用 UTF-8 解码器（在 dart:convert 库中提供）将字节序列转换为 Dart 字符串序列。 流的另一个常见用法是用于 Web 应用程序中用户生成的事件：以下代码侦听按钮上的鼠标单击。 querySelector('#myButton').onClick.listen((_) => print('Click.')); 其他资源 dart:async 库之旅: 异步的简要概述。 Use Future-Based APIs: 仔细研究 Futures 以及如何使用它们编写异步 Dart 代码。 Futures 与错误处理: 您想要了解与使用 Future 时处理错误和异常有关的所有信息（但不敢问）。 事件循环与 Dart: 了解 Dart 如何处理事件队列和微任务队列，以便您编写具有更少“惊喜”的更好的异步代码。 test package: Asynchronous Tests: 如何测试异步代码。 类 "},"jichu/dart_sdk/dart_collection.html":{"url":"jichu/dart_sdk/dart_collection.html","title":"库 dart:collection","keywords":"","body":" 阅读原文 dart:collection 库 补充 dart:core 中的集合支持的类和实用程序。 要在您的代码中使用此库： import 'dart:collection'; 包含的类 "},"jichu/dart_sdk/dart_convert.html":{"url":"jichu/dart_sdk/dart_convert.html","title":"库 dart:convert","keywords":"","body":" 阅读原文 dart:convert 库 编码器和解码器，用于在不同的数据表示形式（包括 JSON 和 UTF-8）之间进行转换。 除了用于通用数据表示的转换器之外，该库还提供了对实现转换器的支持，使转换器易于链接和与流（streams）一起使用。 使用该库： import 'dart:convert'; 两个常用的转换器是 JsonCodec 和 Utf8Codec 的顶级实例（top-level instances），分别命名为 json 和 utf8。 JSON 是一种简单的文本格式，用于表示结构化对象和集合。 JSON编码器/解码器 使用 JSON 格式在字符串和对象结构（例如列表和映射）之间进行转换。 UTF-8 是一种常见的可变宽度编码，可以表示 Unicode 字符集中的每个字符。 UTF-8编码器/解码器 在字符串和字节之间转换。 转换器(Converters)通常与流(streams)一起使用，以转换流中可用的数据。以下代码使用两个转换器。第一个是 UTF-8 解码器，它将从文件中读取的数据从字节转换为 UTF-8，第二个是 LineSplitter 的实例，该实例在换行符边界上拆分数据。 var lineNumber = 1; var stream = File('quotes.txt').openRead(); stream.transform(utf8.decoder) .transform(const LineSplitter()) .listen((line) { if (showLineNumbers) { stdout.write('${lineNumber++} '); } stdout.writeln(line); }); See the documentation for the Codec and Converter classes for information about creating your own converters. 有关创建自己的转换器的信息，请参见 Codec 和 Converter 类的文档。 类 "},"jichu/dart_sdk/dart_io.html":{"url":"jichu/dart_sdk/dart_io.html","title":"库 dart:io","keywords":"","body":" 阅读原文 dart:io 库 对非 Web 应用程序的 File，socket，HTTP 和其他 I/O 支持。 重要提示：基于浏览器的应用程序不能使用此库。只有服务器，命令行脚本和 Flutter移动应用程序才能导入和使用 dart:io。 该库使您可以处理文件(files)，目录(directories)，套接字(sockets)，进程(processes)，HTTP 服务器和客户端等。与输入和输出相关的许多操作都是异步的，并使用 Futures 或 Streams 处理，这两者都在 dart：async 库中定义。 要在代码中使用dart:io库，请执行以下操作: import 'dart:io'; 有关 Dart 中 I/O 的介绍，请参见 dart:io 库之旅。 文件，目录和链接（File, Directory, and Link） File，Directory 或 Link 的实例分别表示本机文件系统中的文件，目录或链接。 您可以通过这些类型的对象来操纵文件系统。例如，您可以重命名文件或目录： File myFile = new File('myFile.txt'); myFile.rename('yourFile.txt').then((\\_) => print('file renamed')); File，Directory 和 Link 类提供的许多方法都是异步运行的，并返回 Future。 FileSystemEntity 文件(File)，目录(Directory)和链接(Link)都扩展了 FileSystemEntity。除了作为这些类的超类之外，FileSystemEntity 还具有许多用于处理路径的静态方法。 要获取有关路径的信息，可以使用 FileSystemEntity 静态方法，例如'isDirectory'，'isFile'和'exists'。由于文件系统访问涉及 I/O，因此这些方法是异步的，并返回 Future。 FileSystemEntity.isDirectory(myPath).then((isDir) { if (isDir) { print('$myPath is a directory'); } else { print('$myPath is not a directory'); } }); HttpServer 和 HttpClient HttpServer 和 HttpClient 类提供 HTTP 服务器和 HTTP 客户端功能。 HttpServer 类提供用于实现 HTTP 服务器的基本功能。对于某些更高级别的构建块，我们建议您尝试一下 shelf pub package，其中包含一组高级类，这些类与该库中的 HttpServer 类一起使实现 HTTP 服务器更加容易。 进程（Process） Process 类提供了一种在本机上运行进程的方法。例如，以下代码产生一个递归列出 Web 下文件的进程。 Process.start('ls', ['-R', 'web']).then((process) { stdout.addStream(process.stdout); stderr.addStream(process.stderr); process.exitCode.then(print); }); 使用 start() 返回一个 Future，当流程开始时，它会以 Process 对象完成。通过此 Process 对象，您可以在 process 运行时与其进行交互。使用 run（）返回一个 Future，当生成的进程终止时，它会以 ProcessResult 对象完成。此 ProcessResult 对象收集 process 的输出和退出代码。 使用 start() 时，您需要读取来自 stdout 和 stderr 流的所有数据，否则将不会释放系统资源。 WebSocket WebSocket 类提供对 Web socket 协议的支持。这允许客户端和服务器应用程序之间的全双工通信(full-duplex communications)。 Web socket 服务器使用普通的 HTTP 服务器来接受 Web socket 连接。初始握手是 HTTP 请求，然后将其升级为 Web socket 连接。服务器使用 WebSocketTransformer 升级请求，并侦听返回的 Web socket 上的数据。例如，这是一个微型服务器，用于侦听 WebSocket 上的“ws”数据： runZoned(() async { var server = await HttpServer.bind('127.0.0.1', 4040); server.listen((HttpRequest req) async { if (req.uri.path == '/ws') { var socket = await WebSocketTransformer.upgrade(req); socket.listen(handleMsg); } }); }, onError: (e) => print(\"An error occurred.\")); 客户端使用 connect()方法和使用 Web 套接字协议的 URI 连接到 WebSocket。客户端可以使用 add()方法写入 WebSocket。例如， var socket = await WebSocket.connect('ws://127.0.0.1:4040/ws'); socket.add('Hello, World!'); 检出 websocket_sample 应用程序，该应用程序使用 WebSockets 与服务器进行通信。 Socket and ServerSocket 客户端和服务器使用 Sockets 通过 TCP 协议进行通信。在服务器端使用 ServerSocket，在客户端使用 Socket。服务器使用 bind() 方法创建一个监听套接字(istening socket)，然后监听套接字上的传入连接。例如： ServerSocket.bind('127.0.0.1', 4041) .then((serverSocket) { serverSocket.listen((socket) { socket.transform(utf8.decoder).listen(print); }); }); 客户端使用 connect() 方法连接 Socket，该方法返回 Future。使用 write()，writeln() 或 writeAll() 是通过 socket 发送数据的最简单方法。例如： Socket.connect('127.0.0.1', 4041).then((socket) { socket.write('Hello, World!'); }); 除了 Socket 和 ServerSocket 外，还可以使用 RawSocket 和 RawServerSocket 类对异步套接字 IO 进行较低级别的访问。 标准输出，错误和输入流 该库提供标准的输出(output)，错误(error)和输入(input)流，分别名为“ stdout”，“ stderr”和“ stdin”。 stdout 和 stderr 流都是 IOSink，并且具有相同的方法和属性集。 要将字符串写入 'stdout'： stdout.writeln('Hello, World!'); 要将对象列表写入 'stderr'： stderr.writeAll([ 'That ', 'is ', 'an ', 'error.', '\\n']); 标准输入流是真正的 Stream，因此它从 Stream 类继承属性和方法。 要从命令行同步读取文本（程序阻止等待用户键入信息）： String inputText = stdin.readLineSync(); 包含的类 "},"jichu/flutter_widget/listTile.html":{"url":"jichu/flutter_widget/listTile.html","title":"listTile","keywords":"","body":"官方文档 "},"jichu/flutter_widget/listView.html":{"url":"jichu/flutter_widget/listView.html","title":"listView","keywords":"","body":"官方文档 "},"jichu/flutter_package/shared_preferences.html":{"url":"jichu/flutter_package/shared_preferences.html","title":"package:shared_preferences","keywords":"","body":" shared_preferences | pub.dev Flutter数据存储之shared_preferences Flutter 基于 shared_preferences 进行持久化键值存储 【翻译】 Shared preferences plugin（共享首选项插件） 包装特定于平台的持久性存储以获取简单数据 （iOS和macOS上为NSUserDefaults，Android上为SharedPreferences等）。数据可以异步保存到磁盘， 并且不能保证写入将在之后保留到磁盘 返回，因此该插件不得用于存储关键数据。 请设置约束为 shared_preferences: '>=0.5.y+x 向后兼容1.0.0版本即将推出 插件已达到稳定的API，我们保证版本“ 1.0.0”将与“ 0.5.y + z”向后兼容。 请使用`shared_preferences：'> = 0.5.y + x 有关更多详细信息，请参见：https://github.com/flutter/flutter/wiki/Package-migration-to-1.0.0 用法 要使用此插件，请将shared_preferences添加为 pubspec.yaml文件中的依赖项. Example import 'package:flutter/material.dart'; import 'package:shared_preferences/shared_preferences.dart'; void main() { runApp(MaterialApp( home: Scaffold( body: Center( child: RaisedButton( onPressed: _incrementCounter, child: Text('Increment Counter'), ), ), ), )); } _incrementCounter() async { SharedPreferences prefs = await SharedPreferences.getInstance(); int counter = (prefs.getInt('counter') ?? 0) + 1; print('Pressed $counter times.'); await prefs.setInt('counter', counter); } Testing 您可以通过运行以下代码在测试中使用初始值填充“ SharedPreferences”： SharedPreferences.setMockInitialValues (Map values); "},"jichu/flutter_package/dio.html":{"url":"jichu/flutter_package/dio.html","title":"package:dio/dio.dart","keywords":"","body":"中文文档 "},"jichu/flutter_package/fluttertoast.html":{"url":"jichu/flutter_package/fluttertoast.html","title":"package:fluttertoast","keywords":"","body":"package:fluttertoast 【翻译】 fluttertoast Flutter Toast 库。 现在，这个Toast库支持两种Toast消息，一种需要BuildContext，而另一种则不需要BuildContext。 Toast with no context 支持平台 Android IOS Web (Uses Toastify-JS) 此功能功能有限，无法控制UI。 需要BuildContext的Toast 支持平台 ALL 完全控制 Toast Toasts 将排队 移除一个 toast 清除队列 如何使用 # 将此行添加到您的依赖项 fluttertoast: ^7.0.4 import 'package:fluttertoast/fluttertoast.dart'; Toast with No Build Context Fluttertoast.showToast( msg: \"This is Center Short Toast\", toastLength: Toast.LENGTH_SHORT, gravity: ToastGravity.CENTER, timeInSecForIosWeb: 1, backgroundColor: Colors.red, textColor: Colors.white, fontSize: 16.0 ); property description default msg String (Not Null)(required) required toastLength Toast.LENGTH_SHORT or Toast.LENGTH_LONG (optional) Toast.LENGTH_SHORT gravity ToastGravity.TOP (or) ToastGravity.CENTER (or) ToastGravity.BOTTOM (Web Only supports top, bottom) ToastGravity.BOTTOM timeInSecForIosWeb int (only for ios) 1 backgroundColor Colors.red null textcolor Colors.white null fontSize 16.0 (float) null webShowClose false (bool) false webBgColor String (hex Color) linear-gradient(to right, #00b09b, #96c93d) webPosition String (left, center or right) right To cancel all the toasts call Fluttertoast.cancel() Custom Toast For Android 在项目“ app /res /layout”文件夹中创建一个名为“ toast_custom.xml”的文件，然后进行自定义样式 Toast with BuildContext FToast fToast; @override void initState() { super.initState(); fToast = FToast(context); } _showToast() { Widget toast = Container( padding: const EdgeInsets.symmetric(horizontal: 24.0, vertical: 12.0), decoration: BoxDecoration( borderRadius: BorderRadius.circular(25.0), color: Colors.greenAccent, ), child: Row( mainAxisSize: MainAxisSize.min, children: [ Icon(Icons.check), SizedBox( width: 12.0, ), Text(\"This is a Custom Toast\"), ], ), ); fToast.showToast( child: toast, gravity: ToastGravity.BOTTOM, toastDuration: Duration(seconds: 2), ); } 现在调用_showToast（） 有关更多详细信息，请查看example项目 property description default child Widget (Not Null)(required) required toastDuration Duration (optional) gravity ToastGravity.* To cancel all the toasts call // To remove present shwoing toast fToast.removeCustomToast() // To clear the queue fToast.removeQueuedCustomToasts(); Preview Images (No BuildContext) Preview Images (BuildContext) "},"jichu/flutter_package/cached_network_image.html":{"url":"jichu/flutter_package/cached_network_image.html","title":"package:cached_network_image","keywords":"","body":"package:cached_network_image Cached network image cached_network_image 是一个 flutter 库，用于显示来自互联网的图像并将其保存在缓存目录中。 如何使用 CachedNetworkImage可以直接使用，也可以通过ImageProvider使用。 作为CachedNetworkImageProvider的CachedNetworkImage都对Web的支持最少。目前不包括缓存。 使用占位符： CachedNetworkImage( imageUrl: \"http://via.placeholder.com/350x150\", placeholder: (context, url) => CircularProgressIndicator(), errorWidget: (context, url, error) => Icon(Icons.error), ), 或带有进度指示器： CachedNetworkImage( imageUrl: \"http://via.placeholder.com/350x150\", progressIndicatorBuilder: (context, url, downloadProgress) => CircularProgressIndicator(value: downloadProgress.progress), errorWidget: (context, url, error) => Icon(Icons.error), ), Image(image: CachedNetworkImageProvider(url)) 如果您想同时拥有占位符功能和要在另一个窗口小部件中使用 imageprovider，则可以提供 imageBuilder： CachedNetworkImage( imageUrl: \"http://via.placeholder.com/200x150\", imageBuilder: (context, imageProvider) => Container( decoration: BoxDecoration( image: DecorationImage( image: imageProvider, fit: BoxFit.cover, colorFilter: ColorFilter.mode(Colors.red, BlendMode.colorBurn)), ), ), placeholder: (context, url) => CircularProgressIndicator(), errorWidget: (context, url, error) => Icon(Icons.error), ), 底层原理 缓存的网络映像使用以下命令存储和检索文件 flutter_cache_manager. "},"jichu/flutter_package/flukit.html":{"url":"jichu/flutter_package/flukit.html","title":"package:flukit","keywords":"","body":"flukit 1.0.2 | pub.dev flukit （Flutter UI Kit）是一个Flutter Widget库。地址：//github.com/flutterchina/flukit "},"jichu/flutter_package/flutter_web_plugins.html":{"url":"jichu/flutter_package/flutter_web_plugins.html","title":"package:flutter_web_plugins","keywords":"","body":"package:flutter_web_plugins flutter_web_plugins 库 类 PluginEventChannel 使用流将事件发送到框​​架端的命名通道。 [...] PluginRegistry 此类注册Web平台插件。 Registrar 特定插件的注册商。 [...] 属性 pluginBinaryMessenger → BinaryMessenger Flutter Web插件的默认BinaryMessenger。 final webPluginRegistry → PluginRegistry Web的默认插件注册表。 final "},"jichu/flutter_package/flutter_localizations.html":{"url":"jichu/flutter_package/flutter_localizations.html","title":"package:flutter_localizations","keywords":"","body":" 国际化Flutter App | 官网 接口文档 "},"jichu/flutter_package/provider.html":{"url":"jichu/flutter_package/provider.html","title":"package:provider","keywords":"","body":" 原文地址 https://flutter.dev/docs/development/packages-and-plugins/favorites InheritedWidget的包装 使它们更易于使用和重用。 通过使用“provider”而不是手动编写InheritedWidget，您将获得： 简化资源的分配/处置 延迟加载 每次制作新课程都大大减少了样板 devtools 友好 消费这些InheritedWidget的常用方法（请参见Provider.of /Consumer /Selector） 通过侦听机制呈指数增长的类，提高了类的可伸缩性 （例如，ChangeNotifier，它是用于分发通知的 O（N²））。 要了解有关provider的更多信息，请参见其 documentation. 也可以看看： 官方 Flutter 状态管理文档, 展示了如何使用“ provider” + ChangeNotifier flutter 使用实例, 其中包含使用“ provider”实现的该应用 + ChangeNotifier flutter_bloc and Mobx, 在他们的架构中使用provider 从 v3.x.0 迁移到 v4.0.0 The parameters builder and initialBuilder of providers are removed. initialBuilder should be replaced by create. builder of \"proxy\" providers should be replaced by update builder of classical providers should be replaced by create. The new create/update callbacks are lazy-loaded, which means they are called the first time the value is read instead of the first time the provider is created. If this is undesired, you can disable lazy-loading by passing lazy: false to the provider of your choice: FutureProvider( create: (_) async => doSomeHttpRequest(), lazy: false, child: ... ) ProviderNotFoundError is renamed to ProviderNotFoundException. The SingleChildCloneableWidget interface is removed and replaced by a new kind of widget SingleChildWidget. See this issue for details on how to migrate. Selector now deeply compares the previous and new values if they are collections. If this is undesired, you can revert to the old behavior by passing a shouldRebuild parameter to Selector: Selector( shouldRebuild: (previous, next) => previous == next, builder: ..., ) DelegateWidget and its family is removed. Instead, for custom providers, directly subclass InheritedProvider or an existing provider. 用法 暴露值 暴露一个新的对象实例 Providers allow to not only expose a value, but also create/listen/dispose it. To expose a newly created object, use the default constructor of a provider. Do not use the .value constructor if you want to create an object, or you may otherwise have undesired side-effects. See this stackoverflow answer which explains in further details why using the .value constructor to create values is undesired. DO create a new object inside create. Provider( create: (_) => MyModel(), child: ... ) DON'T use Provider.value to create your object. ChangeNotifierProvider.value( value: MyModel(), child: ... ) DON'T create your object from variables that can change over the time. In such a situation, your object would never be updated when the value changes. int count; Provider( create: (_) => MyModel(count), child: ... ) If you want to pass variables that can change over time to your object, consider using ProxyProvider: int count; ProxyProvider0( update: (_, __) => MyModel(count), child: ... ) NOTE: When using the create/update callback of a provider, it is worth noting that this callback is called lazily by default. What this means is, until the value is requested at least once, the create/update callbacks won't be called. This behavior can be disabled if you want to pre-compute some logic, using the lazy parameter: MyProvider( create: (_) => Something(), lazy: false, ) 重用现有对象实例： If you already have an object instance and want to expose it, you should use the .value constructor of a provider. Failing to do so may call the dispose method of your object when it is still in use. DO use ChangeNotifierProvider.value to provide an existing ChangeNotifier. MyChangeNotifier variable; ChangeNotifierProvider.value( value: variable, child: ... ) DON'T reuse an existing ChangeNotifier using the default constructor MyChangeNotifier variable; ChangeNotifierProvider( create: (_) => variable, child: ... ) 读取值 The easiest way to read a value is by using the extension methods on [BuildContext]: context.watch(), which makes the widget listen to changes on T context.read(), which returns T without listening to it context.select(R cb(T value)), which allows a widget to listen to only a small part of T. Or to use the static method Provider.of(context), which will behave similarly to watch/read. These methods will look up in the widget tree starting from the widget associated with the BuildContext passed, and will return the nearest variable of type T found (or throw if nothing is found). It's worth noting that this operation is O(1). It doesn't involve actually walking in the widget tree. Combined with the first example of exposing a value, this widget will read the exposed String and render \"Hello World.\" class Home extends StatelessWidget { @override Widget build(BuildContext context) { return Text( // Don't forget to pass the type of the object you want to obtain to `watch`! context.watch(), ); } } Alternatively, instead of using these methods, we can use Consumer and Selector. These can be useful for performance optimizations or when it is difficult to obtain a BuildContext descendant of the provider. See the FAQ or the documentation of Consumer and Selector for more information. MultiProvider When injecting many values in big applications, Provider can rapidly become pretty nested: Provider( create: (_) => Something(), child: Provider( create: (_) => SomethingElse(), child: Provider( create: (_) => AnotherThing(), child: someWidget, ), ), ), To: MultiProvider( providers: [ Provider(create: (_) => Something()), Provider(create: (_) => SomethingElse()), Provider(create: (_) => AnotherThing()), ], child: someWidget, ) The behavior of both examples is strictly the same. MultiProvider only changes the appearance of the code. ProxyProvider Since the 3.0.0, there is a new kind of provider: ProxyProvider. ProxyProvider is a provider that combines multiple values from other providers into a new object, and sends the result to Provider. That new object will then be updated whenever one of the providers it depends on updates. The following example uses ProxyProvider to build translations based on a counter coming from another provider. Widget build(BuildContext context) { return MultiProvider( providers: [ ChangeNotifierProvider(create: (_) => Counter()), ProxyProvider( update: (_, counter, __) => Translations(counter.value), ), ], child: Foo(), ); } class Translations { const Translations(this._value); final int _value; String get title => 'You clicked $_value times'; } It comes under multiple variations, such as: ProxyProvider vs ProxyProvider2 vs ProxyProvider3, ... That digit after the class name is the number of other providers that ProxyProvider depends on. ProxyProvider vs ChangeNotifierProxyProvider vs ListenableProxyProvider, ... They all work similarly, but instead of sending the result into a Provider, a ChangeNotifierProxyProvider will send its value to a ChangeNotifierProvider. FAQ（常问问题） 我可以检查对象的内容吗 Flutter comes with a devtool that shows what the widget tree is at a given moment. Since providers are widgets, they are also visible in that devtool: From there, if you click on one provider, you will be able to see the value it exposes: (screenshot of the devtools using the example folder) devtool 仅显示“ MyClass 实例”。我能做什么？ By default, the devtool relies on toString, which defaults to \"Instance of MyClass\". To have something more useful, you have two solutions: use the Diagnosticable API from Flutter. For most cases, that will be done my using DiagnosticableTreeMixin on your objects, followed by a custom implementation of debugFillProperties. class MyClass with DiagnosticableTreeMixin { MyClass({this.a, this.b}); final int a; final String b; @override void debugFillProperties(DiagnosticPropertiesBuilder properties) { super.debugFillProperties(properties); // list all the properties of your class here. // See the documentation of debugFillProperties for more information. properties.add(IntProperty('a', a)); properties.add(StringProperty('b', b)); } } override toString. If you cannot use DiagnosticableTreeMixin (like if your class is in a package that does not depend on Flutter), then you can simply override toString. This is easier than using DiagnosticableTreeMixin but is less powerful: You will not be able to expand/collapse the details of your object. class MyClass with DiagnosticableTreeMixin { MyClass({this.a, this.b}); final int a; final String b; @override String toString() { return '$runtimeType(a: $a, b: $b)'; } } 在initState中获取 Provider 时出现异常。我能做什么？ This exception happens because you're trying to listen to a provider from a life-cycle that will never ever be called again. It means that you either should use another life-cycle (build), or explicitly specify that you do not care about updates. As such, instead of: initState() { super.initState(); print(context.watch().value); } you can do: Value value; Widget build(BuildContext context) { final value = context.watch.value; if (value != this.value) { this.value = value; print(value); } } which will print value whenever it changes (and only when it changes). Alternatively you can do: initState() { super.initState(); print(context.read().value); } Which will print value once and ignore updates. 如何处理对象的热重装？ You can make your provided object implement ReassembleHandler: class Example extends ChangeNotifier implements ReassembleHandler { @override void reassemble() { print('Did hot-reload'); } } Then used normally with provider: ChangeNotifierProvider(create: (_) => Example()), 我使用ChangeNotifier，更新时出现异常，会是因为什么？ This likely happens because you are modifying the ChangeNotifier from one of its descendants while the widget tree is building. A typical situation where this happens is when starting an http request, where the future is stored inside the notifier: initState() { super.initState(); context.read().fetchSomething(); } This is not allowed, because the modification is immediate. Which means that some widgets may build before the mutation, while other widgets will build after the mutation. This could cause inconsistencies in your UI and is therefore not allowed. Instead, you should perform that mutation in a place that would affect the entire tree equally: directly inside the create of your provider/constructor of your model: class MyNotifier with ChangeNotifier { MyNotifier() { _fetchSomething(); } Future _fetchSomething() async {} } This is useful when there's no \"external parameter\". asynchronously at the end of the frame: initState() { super.initState(); Future.microtask(() => context.read(context).fetchSomething(someValue); ); } It is slightly less ideal, but allows passing parameters to the mutation. Do I have to use ChangeNotifier for complex states? No. You can use any object to represent your state. For example, an alternate architecture is to use Provider.value() combined with a StatefulWidget. Here's a counter example using such architecture: class Example extends StatefulWidget { const Example({Key key, this.child}) : super(key: key); final Widget child; @override ExampleState createState() => ExampleState(); } class ExampleState extends State { int _count; void increment() { setState(() { _count++; }); } @override Widget build(BuildContext context) { return Provider.value( value: _count, child: Provider.value( value: this, child: widget.child, ), ); } } where we can read the state by doing: return Text(context.watch().toString()); and modify the state with: return FloatingActionButton( onPressed: () => context.read().increment(), child: Icon(Icons.plus_one), ); Alternatively, you can create your own provider. Can I make my own Provider? Yes. provider exposes all the small components that make a fully-fledged provider. This includes: SingleChildStatelessWidget, to make any widget works with MultiProvider.This interface is exposed as part of package:provider/single_child_widget InheritedProvider, the generic InheritedWidget obtained when doing context.watch. Here's an example of a custom provider to use ValueNotifier as state: https://gist.github.com/rrousselGit/4910f3125e41600df3c2577e26967c91 My widget rebuilds too often, what can I do? Instead of context.watch, you can use context.select to listen only to a specific set of properties on the obtained object. For example, while you can write: Widget build(BuildContext context) { final person = context.watch(); return Text(person.name); } It may cause the widget to rebuild if something other than name changes. Instead, you can use context.select to listen only to the name property: Widget build(BuildContext context) { final name = context.select((Person p) => p.name); return Text(name); } This way, the widget won't unnecessarily rebuild if something other than name changes. Similarly, you can use Consumer/Selector. Their optional child argument allows to rebuild only a very specific part of the widget tree: Foo( child: Consumer( builder: (_, a, child) { return Bar(a: a, child: child); }, child: Baz(), ), ) In this example, only Bar will rebuild when A updates. Foo and Baz won't unnecessarily rebuild. Can I obtain two different providers using the same type? No. While you can have multiple providers sharing the same type, a widget will be able to obtain only one of them: the closest ancestor. Instead, you must explicitly give both providers a different type. Instead of: Provider( create: (_) => 'England', child: Provider( create: (_) => 'London', child: ..., ), ), Prefer: Provider( create: (_) => Country('England'), child: Provider( create: (_) => City('London'), child: ..., ), ), Can I consume an interface and provide an implementation? Yes, a type hint must be given to the compiler to indicate the interface will be consumed, with the implementation provided in create. abstract class ProviderInterface with ChangeNotifier { ... } class ProviderImplementation with ChangeNotifier implements ProviderInterface { ... } class Foo extends StatelessWidget { @override build(context) { final provider = Provider.of(context); return ... } } ChangeNotifierProvider( create: (_) => ProviderImplementation(), child: Foo(), ), Existing providers “ provider”为不同类型的对象提供了几种不同的“ provider”。 所有可用对象的完整列表是在here name description Provider provider 的最基本形式。无论值是多少，它都会获取一个值并将其公开。 ListenableProvider 侦听对象的特定 Provider。每当调用侦听器时，ListenableProvider 都会侦听该对象并要求依赖于该对象的小部件进行重建。 ChangeNotifierProvider 用于 ChangeNotifier 的 ListenableProvider 的规范。必要时它将自动调用ChangeNotifier.dispose。 ValueListenableProvider 听一个 ValueListenable，只暴露ValueListenable.value。 StreamProvider 收听流，并公开发出的最新值。 FutureProvider 接受“Future”并在将来完成时更新依赖项。 推荐阅读 Flutter 状态管理之 Provider "},"advance/stream.html":{"url":"advance/stream.html","title":"Dart | 什么是 Stream","keywords":"","body":"推荐阅读 Dart | 什么是 Stream "},"advance/dio-getting.html":{"url":"advance/dio-getting.html","title":"Http 网络请求-dio","keywords":"","body":" Flutter Http 请求开源库-dio Flutter 网络请求之 dio Flutter 网络请求 Dio 封装 Flutter Dio 二次封装 "},"advance/bloc.html":{"url":"advance/bloc.html","title":"Flutter | 状态管理(3) - BLoC 模式入门","keywords":"","body":"BLoC是 Business Logic Components 的缩写, 是paolo soares 和 cong hui 在2018年Google dartconf上提出的。BLoC的哲学就是app里的所有东西都应该被认为是事件流：一部分组件订阅事件，另一部分组件则响应事件。BLoC居中管理这些会话。Dart甚至把流（Stream）内置到了语言本身里。 这个模式最好的地方就是你不需要引入任何的插件，也不需要学习其他的语法。所有需要的内容Flutter都有提供。 深入 BLoC BLoC基本就是基于Dart的流（Stream）的。 流，和Future一样，也是在 dart:async 包里。一个流就像一个future，不同的是流不只是异步的返回一个值，流可以随着时间的推移返回很多的值。如果一个future最终是一个值的话，那么一个流就是会随着时间可以返回一个系列的值。 dart:async 包提供了一个 StreamController 类。流控制器管理的两个对象流和槽（sink）。sink和流相对应，流提供提供数据，sink接受输入值。 总结一下，BLoC用来处理逻辑，sink接受输入，流输出。 推荐阅读 flutter中使用BloC模式 Flutter - BLoC模式入门 [译] 在 flutter 中高效地使用 BLoC 模式 bloc "},"advance/rxdart.html":{"url":"advance/rxdart.html","title":"Flutter | 状态管理(4) - RxDart","keywords":"","body":"推荐阅读 Flutter | 状态管理拓展篇——RxDart(四) Flutter 响应式编程 - RxDart RxDart 中文文档 ｜ rxdart 0.24.1 "}}