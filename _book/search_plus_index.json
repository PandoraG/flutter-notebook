{"./":{"url":"./","title":"Introduction","keywords":"","body":"Introduction "},"jichu/dart-getting.html":{"url":"jichu/dart-getting.html","title":"dart 基础入门","keywords":"","body":"1、Dart 基础知识 1.1 程序入口 Js 没有预定义的入口函数，但在 Dart 中，每个 app 都必须有一个顶级的 main() 函数作为应用程序的入口点。 // Dart main() { } DartPad是 Dart 的一个线上 playground, 提供 Dart 线上 playground 还有：Online dart compiler 1.2 控制台输出 要在 Dart 中打印到控制台，可使用 print: // js console.log('hello world'); // dart print('hello world'); 1.3 变量 Dart 是类型安全的 - 它使用静态类型检查和运行时的组合，检查以确保变量的值始终与变量的静态值匹配 类型。尽管类型是必须的，但某些类型注释是可选的，因为 Dart 会执行类型推断。 1.3.1 创建变量 在 js 中，无法定义变量类型。 在 dart 中，变量必须是明确的 类型和系统能够解析的类型。 // js var name = 'js' // dart String name = 'dart'; //明确指定是String类型 var othername = 'Dart'; //推断为string // 以上两种情况在dart中都是可行的 1.3.2 默认值 在 js 中，未初始化的变量是 undefined。 在 dart 中，未初始化的变量的初始值是 null。 注意：数字在 Dart 中也被当成对象，所以只要是带有数字类型的未初始化变量的值都是 “null”。 // js var name; // == undefined // Dart var name; // == null int x; // == null 1.4 检查 null 或零 在 Js 中， 1或任何非 null 对象的值被视为 true。 // Js var myNull = null; if (!myNull) { console.log('null is treated as false'); } var zero = 0; if (!zero) { console.log(\"0 is treated as false); } 在 Dart 中，只有布尔值 “true”被视为 true。 // Dart var myNull = null; if (myNull == null) { print('user \"== null\" to check null'); } var zero = 0; if (zero == 0) { print('user \"== 0\" to check zero'); } 1.4.1 Dart null 检查最佳实践 从 Dart 1.12 开始，null-aware运算符 可用帮助我们做null检查： bool isConnected(a, b) { bool outConn = outgoing[a]?.contains(b) ?? false; bool inConn = incoing[a].contains(b) ?? false; return outConn || isConn; } ?.运算符在左边为 null 情况下会阻断右边的调用，??运算符主要作用是在左侧表达式为 null 时为其设置默认值。 对于表达式： outgoing[a]?.contains(b); 如果 outgoing 为 null 或 outgoing[a]为 null 或 contains(b)的值为 null，都会导致表达式为 null。 print(null ?? false) //false print(false ?? 11); //11 print(true ?? false); //true 技巧： 获取一个对象中数组的长度： searchModel?.data?.length ?? 0。 1.5 Functions Dart 和 JavaScript 函数类似，主要区别是声明： // js es5 function fn() { return true; } // Dart fn() { return false; } // 也可以写成这样 bool fn() { return false; } 1.6 异步编程 1.6.1 Futures 与 Js 一样，Dart 支持单线程执行。在 JavaScript 中，Promise对象表示异步操作的最终完成（或失败）及其结果值，Dart 中使用 Future 来表示异步操作： // js _getIpAddress = () => { const url = 'https://httpbin.org/ip'; return fetch(url) .then(response => response.json()); .then(responseJson => { console.log(responseJson.origin()); }) .catch(error => { console.error(error); }) } // Dart _getIpAddress() { final url = 'https://httpbin.org/ip'; HttpRequest.request(url).then((value) { print(json.decode(value.responseText)['origin']); }).catchError((error) => print(error)); } 实例： import 'dart:convert'; import 'dart:html'; void main() { _getIpAddress() { final url = 'https://httpbin.org/ip'; Future request = HttpRequest.request(url); request.then((value) { print(json.decode(value.responseText)['origin']); }).catchError((error) => print(error)); } _getIpAddress(); } 1.6.2 async 和 await async 函数声明定义一个异步函数。 在 JavaScript 中，async函数返回一个 Promise 对象。await运算符是用在等待Promise； // javascript async _getIpAddress() { const url = 'https://httpbin.org/ip'; const response = await fetch(url); const json = await response.json(); const data = await json.origin(); console.log(data); } 在 Dart 中，async函数返回一个Future, 函数的主题是稍后执行的。await运算符用于等待 Future。 _getIpAddress() async { final url = 'https://httpbin.org/ip'; var request = await HttpRequest.request(url); //通过await标识请求，返回的是一个Future String ip = json.decode(request.responseText['origin']) //通过resposneText获取具体ip print(ip) } "},"jichu/what-is-declarative-ui.html":{"url":"jichu/what-is-declarative-ui.html","title":"什么是声明式 UI","keywords":"","body":"1、什么是声明式 UI Flutter 采用了声明性 UI 布局方式，为了帮助大家快速上手，我们要先学习什么是声明式 UI, 以及它和我们常用的命令式 UI 的异同。 1.1 为什么是声明式 UI？ 从 Win32 到 Web 在到 Android 和 iOS 的框架通常使用命令式的 UI 编程风格。这可能是我们最熟悉的样式 - 你手动构建全功能 UI 实体（如 UIView 或等效实体），然后在 UI 更改时使用方法对其进行更改。 为了减轻开发人员在各种 UI 状态之间转换的编程负担，Flutter 让开发人员描述当前的 UI 状态，并不需要关心她是如何过渡到框架。 虽然声明式 UI 能帮我们减轻很多负担，但大家要将布局的思维方式要转变过来。 1.2 如何在声明框架中更改 UI? 下面是个简单的例子： 为了将上图左侧样式改成右边的样子，在命令样式中，我们通常会获取的 ViewB 的实例，然后改变其颜色，然后将启动的元素删除，在添加 ViewC c3: // Imperative style b.setColor(red) b.clearChildren() ViewC c3 = new ViewC(...) b.add(c3) 在声明式 UI 中，视图配置（例如 Flutter 的 widget）是不变的，并且只是轻量级“蓝图”。要更改 UI，Widget 会在自身上触发重建（最常见的是通过在 Flutter 中的 StatefulWidgets 上调用 setState()) 并构建一个新的 Widgets 子树： // Declarative style return ViewB( color: red, child: ViewC(....), ) 这里，Flutter 构建新的 Widget 实例，而不是在 UI 更改时改变旧实例 b。 该框架使用 RenderObjects 管理传统 UI 对象的许多职责（例如维护布局的状态）。RenderObjects 在帧之间保持不变，Flutter 的轻量级 Widgets 告诉框架在状态 RenderObjects，接下来 Flutter 框架会处理其与部分。 "},"jichu/flutter-getting.html":{"url":"jichu/flutter-getting.html","title":"Flutter 入门基础","keywords":"","body":"1 如何创建 Flutter 项目？ 要创建一个 Flutter 项目有一下两种方式： 从命令行使用 flutter create 命令。确保 flutter SDK 配置了环境变量。 使用安装了 Flutter 和 Dart 插件的 IDE。 $ flutter create 2 如何运行 Flutter 项目？ 在 Flutter 中，我们通过以下两种方式来运行项目： 从项目的根目录使用 flutter run。 在带有 Flutter 和 Dart 插件的 IDE 中使用 “run” 选项。 $ flutter run -d 'iphone X' d 后面跟的是具体的设备名称，可以是 Android 或 iOS 模拟器的名字，也可以一台已经连接到电脑上的 Android 或 iOS 的设备。 3 如何导入 Widget? 在 Flutter 中，要使用 Material Design 库中的小部件，则需要导入 material.dart 包。要使用 iOS 样式 widget, 请导入Cupertino 库。要使用更基本的窗口 widget 集，请导 widget 库。或者，当然，也可以导入自己编写的 widget: import 'package:flutter/material.dart'; //导入系统material widget库 import 'package:flutter/cupertino.dart'; import 'package:flutter/widgets.dart'; import 'package:flutter/my_widgets.dart'; //导入自己的widget 无论您导入哪个 widget 包，Dart 都只会导入在您的应用中使用的 widget。 4 如何写一个 Hello world? 在 Flutter 中，您可以创建一个完全相同的“Hello world!” 应用程序使用核心窗口小部件库中 Center 和 Text 窗口小部件。Center 窗口小部件成为窗口小部件树的根，并且有一个子窗口，即“Text”窗口小部件。 // Flutter import 'package:flutter/material.dart'; void main() { runApp( Center( child: Text( 'Hello world!', textDirection: TextDirection.ltr, ), ), ); } 得益于 Flutter 强大的封装能力，我们不难发现实现相同的功能，Flutter 要比 RN 少很多代码。 5 如何使用 Widget 并将其嵌套以形成 Widget 树？ 在 Flutter 中，几乎所有东西都是 widget。 widget 是用户界面的基本构建块，您将 widget 组成一个层次结构，调用 widget 树。每个窗口 widget 都嵌套在父窗口 widget 中，并从其父窗口继承属性。甚至应用程序对象本身也是一个组件，并没有单独的“应用程序”对象。相反，根 widget 担任此角色。 Widget 可以定义： 结构元素 - 如按钮或菜单 文本元素 - 像字体或颜色主题 类似布局的填充或对齐的一个方向 以下示例使用 Material 库中的 Widget 显示“Hello world!” 应用程序。在此示例中，widget 树嵌套在 MaterialApp 的根 widget 中。 // Flutter import 'package:flutter/material.dart'; void main() => runApp(myApp()); class MyApp extends StatelessWidget { @override Widget build(BuildContext context) { return MaterialApp( title: 'Welcome to Flutter', home: Scaffold( appBar: AppBar( title: Text('Welcome to Flutter'), ), body: Center( child: Text('Hello world'), ), ), ); } } 以上图片显示了使用 Material Design 小部件构建的“Hello world!\"。 6 如何创建可重用 Widget? 在 Flutter 中，同样需要定义一个类来创建自定义 widget，然后重用 widget。您还可以定义和调用返回可重用小部件的函数，如以下示例中的构建函数所示： //Flutter class CustomCard extents StatelessWidget { CustomCard({@required this.index, @required this.onPress}); final index; final Function onPress; @override Widget build(BuildContext context) { return Card( child: Column( children: [ Text('Card $index'), FlatButton( child: const Text('Press'), onPressed: this.onPress, ), ], ) ); } } ... // Usage CustomCard( index: index, onPress: () { print('Card $index'); }, ) ... 在前面的例子中，CustomCard 类的构造函数使用 Dart 的大括号语法{}来配置可选参数。 如果要表示必须的字段，请从构造函数中删除花括号，或者将@required 添加到构造函数中。 "},"jichu/project-structure-resources.html":{"url":"jichu/project-structure-resources.html","title":"项目结构、资源、依赖和本地化","keywords":"","body":"1 项目的结构时怎样子的？ projextnam android - Android部分的工程文件 build - 项目的构建输出目录 ios - ios部分的工程文件 lib - 项目中的Dart源文件 src - 包含其他源码的文件 main.dart - 自动生成的项目入口文件，类似于RN的index.js文件 test - 测试相关文件 pubspec.yaml - 项目依赖配置文件类似于RN的package.json 2 在哪里归档图片资源以及如何处理不同分辨率？ 虽然 Android 将 resources 和 assets 区别对待，但在 Flutter 中它们都会被作为 assets 处理，所 有存在于 Android 上 res / drawable- * 文件夹中的资源都放在 Flutter 的 assets 文件夹中。 与 Android 类似，iOS 同样将 images 和 assets 作为不同的东西，而 Flutter 中只有 assets。 被放到 iOS 中 Images.xcasset 文件央下的资源在 Rutter 中被放到了 assets 文件央中。 在 Flutter 中 assets 可以是任意类型的文件，而不仅仅是图片。 例如，你可以把 json 文件放置到 my-assets 文件夹中。 my-assets/data.json 记得在 pubspec.yaml 文件中声明 assets : assets: - my-assets/data.json 然后在代码中我们可以通过 AssetBundle 来访问它: import 'dart:async' show Future; import 'package:f1utter/services.dart' show rootBundle; Future loadAsset() async { return await rpotBundle.loadString('my-assets/data.json'); } 对于图片，Flutter 像 iOS—样，遵循了一个简单的基于像素密度的格式。Image assets 可能是 1.Ox 2.0x 3.0x 或是其他的任何倍数。这个 devicePixelRatio 表示了物理像素到单个逻辑像素的比率。 Android 不同像素密度的图片和 Flutter 的像素比率的对应关系 ldpi 0.75px mdpi 1.0px hdpi 1.5px xhdpi 2.0px xxhdpi 3.0px xxxhdpi 4.0px Assets 可以被放置到任何属性文件夹中一一 Rutter 并没有预先定义的文件结构。我们需要在 pubspec.yaml 文件中声明 assets 的位置，然后 Flutter 会把他们识别出来。 举个例子，要把_个名为 my_icon.png 的图片放到 Flutter 工程中，你可能想要把它放到 images 文件夹中。把图片（1.0x)放置到 images 文件央中，并把其它分辨率的图片放在对应的子文件央中，并接上合适的比例系数，就像这样： images/my_icon.png // Base: 1.0x image images/2.0x/my一icon■png // 2.0x image images/3.0x/my一icon.png //3.0x image 接下来就可以在 pubspec.yaml 文件中这样声明这个图片资源: asserts: - images/my_icon.png 现在，我们就可以借助 Assetlmage 来访问它了。 return AssetImage('images/a_dot_burr.jpeg'); 也可以通过 Image widget 直接使用： @override Widget build(BuildContext context) { return Image.asset(\"images/my_image.png\"); } 3 如何归档 strings 资源，以及如何处理不同语言？ 不像 iOS 拥有一个 Localizaple. strings 文件，Flutter 目前没有专门的字符串资源系统。目 前，最佳做法是将 strings 资源作为静态字段保存在类中。例如： class Strings { static String welcomeMessage = \"Welcome To Flutter\"; } 然后像如下方式来访问它: Text(Strings.welcomeMessage) 默认情况下，Flutter 只支持美式英语字符串。如果你要支持其他语言，请引入 flutter_Localizations包。你可能也要引入 inti 包来支持其他的 i10n 机制，比如日期/时间格式化。 dependencies: # ... flutte「一localizations: sdk: flutter intl: \"^0.15.6\" 要使用 flutter_localizations 包 ， 还需要在 appwidget 中指定 localizationsDelegates 和 supportedLocales。 import 'packagerflutter_localizations/flutter_localizations.dart'; MaterialApp( localizationsDelegates: [ // Add app-specific localization delegate[s] here GlobaIMaterialLocalizations.delegate, GlobalWidgetsLocalizations.delegate, ], supportedLocales: [ const Locale(,en'# 'US'), // English const Locale('he', 'IL'), // Hebrew // ... other locales the app supports ], // ... } 这些代理包括了实际的本地化值，并且 supportedLocales 定义了 App 支持哪些地区。上面的例子使用了一个 MaterialApp, 所以它既有 GlobaIWidgetsLocalizations 用于基础 widgets, 也有 MateriaIWidgetsLocalizations 用于 Material wigets 的本地化。如果你使用 WidgetsApp，则无需包括后者。注意，这两个代理虽然包括了“默认”值，但如果你想让你的 App 本地化，你仍需要提供一或多个代理作为你的 App 本她化副本。 当初始化时，WidgetsApp 或 MaterialApp 会使用你指定的代理为你创建一个 Localizations widget。Localizations widget 可以随时从当前上下文中访问设备的地点，或者使用 Window.locale。 要访问本地化文件，使用 Localizations.of()方法来访问提供代理的特定本地化类。如需翻译，使用 intl_translation 包来取出翻译副本到 arb 文件中。把它们引入 App 中，并用 inti 来使用它们。 更多 Flutter 中国际化和本地化的细节，请访问 internationalization guide , 里面有不使用 inti 包的 示例代码。 注意，在 Flutter 1.0 beta 2 之前，在 Flutter 中定义的 assets 不能再原生一侧被访问。原生定义的资源在 Flutter 中也不可用，因为它们在独立的文件夹中。 4 如何添加 Flutter 项目所需的依赖？ 在 Android 中，你可以在 Gradle 文件来添加依赖项目； 在 iOS 中，通常把依赖添加到 Podfile 中； 在 RN 中，通常是由 package.json 来管理项目依赖； Flutter 使用 Dart 构建系统和 Pub 包管理器来处理依赖。这些工具将 Android 和 iOS native 包装应用程序的构建委派给响应的构建系统。 dependencies: flutter: sdk: flutter google_sign_in: ^3.0.3 在 Flutter 中，虽然在 Flutter 项目中的 Android 文件夹下有 Gradle 文件，但只有在添加平台相关需求的依赖关系时才会使用到这些文件。否则，应该使用 pubspec.yaml 来声明用于 Flutter 的外部依赖项。 iOS 也一样，如果你的 Flutter 工程中的 iOS 文件夹中有 Podfile， 请仅在添加 iOS 平台相关依赖时使用它。否则，应该使用 pubspec.yaml 来声明用于 Flutter 的外部依赖项。 推荐一个用于查找 Flutter 插件的网站： Pub site。 "},"jichu/know-view.html":{"url":"jichu/know-view.html","title":"认识视图（Views）","keywords":"","body":"https://www.devio.org/2019/03/16/flutter-views/ "},"jichu/state-manage.html":{"url":"jichu/state-manage.html","title":"状态管理","keywords":"","body":"https://www.devio.org/2019/03/23/flutter-statelesswidget-statefulwidget/ "},"jichu/route-and-navigation.html":{"url":"jichu/route-and-navigation.html","title":"路由与导航","keywords":"","body":"https://www.devio.org/2019/03/31/flutter-router-navigator/ "},"advance/stream.html":{"url":"advance/stream.html","title":"Dart | 什么是 Stream","keywords":"","body":"推荐阅读 Dart | 什么是 Stream "},"advance/dio-getting.html":{"url":"advance/dio-getting.html","title":"Http 网络请求-dio","keywords":"","body":" Flutter Http 请求开源库-dio Flutter 网络请求之 dio Flutter 网络请求 Dio 封装 Flutter Dio 二次封装 "},"advance/bloc.html":{"url":"advance/bloc.html","title":"Flutter | 状态管理(3) - BLoC 模式入门","keywords":"","body":"BLoC是 Business Logic Components 的缩写, 是paolo soares 和 cong hui 在2018年Google dartconf上提出的。BLoC的哲学就是app里的所有东西都应该被认为是事件流：一部分组件订阅事件，另一部分组件则响应事件。BLoC居中管理这些会话。Dart甚至把流（Stream）内置到了语言本身里。 这个模式最好的地方就是你不需要引入任何的插件，也不需要学习其他的语法。所有需要的内容Flutter都有提供。 深入 BLoC BLoC基本就是基于Dart的流（Stream）的。 流，和Future一样，也是在 dart:async 包里。一个流就像一个future，不同的是流不只是异步的返回一个值，流可以随着时间的推移返回很多的值。如果一个future最终是一个值的话，那么一个流就是会随着时间可以返回一个系列的值。 dart:async 包提供了一个 StreamController 类。流控制器管理的两个对象流和槽（sink）。sink和流相对应，流提供提供数据，sink接受输入值。 总结一下，BLoC用来处理逻辑，sink接受输入，流输出。 推荐阅读 flutter中使用BloC模式 Flutter - BLoC模式入门 [译] 在 flutter 中高效地使用 BLoC 模式 bloc "},"advance/rxdart.html":{"url":"advance/rxdart.html","title":"Flutter | 状态管理(4) - RxDart","keywords":"","body":"推荐阅读 Flutter | 状态管理拓展篇——RxDart(四) Flutter 响应式编程 - RxDart RxDart 中文文档 ｜ rxdart 0.24.1 "}}